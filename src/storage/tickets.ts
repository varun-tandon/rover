import { writeFile, mkdir, readdir } from 'node:fs/promises';
import { existsSync } from 'node:fs';
import { join } from 'node:path';
import type { ApprovedIssue, Vote } from '../types/index.js';
import { getRoverDir } from './issues.js';

const TICKETS_DIR = 'tickets';

/**
 * Get the path to the tickets directory
 */
export function getTicketsDir(targetPath: string): string {
  return join(getRoverDir(targetPath), TICKETS_DIR);
}

/**
 * Ensure the tickets directory exists
 */
export async function ensureTicketsDir(targetPath: string): Promise<void> {
  const ticketsDir = getTicketsDir(targetPath);
  if (!existsSync(ticketsDir)) {
    await mkdir(ticketsDir, { recursive: true });
  }
}

/**
 * Generate the next ticket number
 */
async function getNextTicketNumber(targetPath: string): Promise<number> {
  const ticketsDir = getTicketsDir(targetPath);

  if (!existsSync(ticketsDir)) {
    return 1;
  }

  try {
    const files = await readdir(ticketsDir);
    const ticketNumbers = files
      .filter(f => f.startsWith('ISSUE-') && f.endsWith('.md'))
      .map(f => {
        const match = f.match(/ISSUE-(\d+)\.md/);
        return match?.[1] ? parseInt(match[1], 10) : 0;
      })
      .filter(n => !isNaN(n));

    return ticketNumbers.length > 0 ? Math.max(...ticketNumbers) + 1 : 1;
  } catch {
    return 1;
  }
}

/**
 * Format a ticket number with leading zeros
 */
function formatTicketNumber(num: number): string {
  return `ISSUE-${num.toString().padStart(3, '0')}`;
}

/**
 * Format a vote for display in the ticket
 */
function formatVote(vote: Vote, index: number): string {
  const status = vote.approve ? 'Approved' : 'Rejected';
  return `- **Voter ${index + 1}**: ${status} - "${vote.reasoning}"`;
}

/**
 * Generate the markdown content for a ticket
 */
export function generateTicketMarkdown(
  issue: ApprovedIssue,
  ticketId: string
): string {
  const lines: string[] = [];

  // Header
  lines.push(`# ${ticketId}: ${issue.title}`);
  lines.push('');

  // Metadata
  lines.push(`**Severity**: ${issue.severity.charAt(0).toUpperCase() + issue.severity.slice(1)}`);
  lines.push(`**Category**: ${issue.category}`);
  lines.push(`**Detected by**: ${issue.agentId}`);

  // File location
  if (issue.lineRange) {
    lines.push(`**File**: \`${issue.filePath}:${issue.lineRange.start}-${issue.lineRange.end}\``);
  } else {
    lines.push(`**File**: \`${issue.filePath}\``);
  }

  lines.push('');

  // Description
  lines.push('## Description');
  lines.push('');
  lines.push(issue.description);
  lines.push('');

  // Code snippet if available
  if (issue.codeSnippet) {
    lines.push('## Problematic Code');
    lines.push('');
    lines.push('```typescript');
    lines.push(issue.codeSnippet);
    lines.push('```');
    lines.push('');
  }

  // Recommendation
  lines.push('## Recommendation');
  lines.push('');
  lines.push(issue.recommendation);
  lines.push('');

  // Voting summary
  lines.push('## Voting Summary');
  lines.push('');

  const approveCount = issue.votes.filter(v => v.approve).length;
  const totalVotes = issue.votes.length;
  lines.push(`**Result**: ${approveCount}/${totalVotes} votes to approve`);
  lines.push('');

  for (let i = 0; i < issue.votes.length; i++) {
    const vote = issue.votes[i];
    if (vote) {
      lines.push(formatVote(vote, i));
    }
  }

  lines.push('');

  // Footer
  lines.push('---');
  const date = new Date(issue.approvedAt).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
  lines.push(`*Generated by Rover on ${date}*`);

  return lines.join('\n');
}

/**
 * Result from creating a single ticket file.
 * Contains both the path to the created file and the issue with ticketPath populated.
 */
export interface CreateTicketResult {
  /** Path to the created ticket file */
  path: string;
  /** The issue with ticketPath field populated (original issue is not mutated) */
  issue: ApprovedIssue;
}

/**
 * Create a ticket file for an approved issue.
 * Returns both the path and a new issue object with ticketPath set (does not mutate input).
 */
export async function createTicketFile(
  targetPath: string,
  issue: ApprovedIssue
): Promise<CreateTicketResult> {
  await ensureTicketsDir(targetPath);

  const ticketNum = await getNextTicketNumber(targetPath);
  const ticketId = formatTicketNumber(ticketNum);
  const ticketPath = join(getTicketsDir(targetPath), `${ticketId}.md`);

  // Create a new issue object with ticketPath set (no mutation)
  const updatedIssue: ApprovedIssue = {
    ...issue,
    ticketPath
  };

  const content = generateTicketMarkdown(updatedIssue, ticketId);
  await writeFile(ticketPath, content, 'utf-8');

  return { path: ticketPath, issue: updatedIssue };
}

/**
 * Result from creating multiple ticket files.
 */
export interface CreateTicketFilesResult {
  /** Paths to all created ticket files */
  paths: string[];
  /** Issues with ticketPath fields populated (original issues are not mutated) */
  issues: ApprovedIssue[];
}

/**
 * Create ticket files for multiple approved issues.
 * Returns both the paths and new issue objects with ticketPath set (does not mutate inputs).
 */
export async function createTicketFiles(
  targetPath: string,
  issues: ApprovedIssue[]
): Promise<CreateTicketFilesResult> {
  const paths: string[] = [];
  const updatedIssues: ApprovedIssue[] = [];

  for (const issue of issues) {
    const result = await createTicketFile(targetPath, issue);
    paths.push(result.path);
    updatedIssues.push(result.issue);
  }

  return { paths, issues: updatedIssues };
}

/**
 * Get all existing ticket files
 */
export async function getExistingTickets(targetPath: string): Promise<string[]> {
  const ticketsDir = getTicketsDir(targetPath);

  if (!existsSync(ticketsDir)) {
    return [];
  }

  try {
    const files = await readdir(ticketsDir);
    return files
      .filter(f => f.startsWith('ISSUE-') && f.endsWith('.md'))
      .sort()
      .map(f => join(ticketsDir, f));
  } catch {
    return [];
  }
}
